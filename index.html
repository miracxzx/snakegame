<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yılan Oyunu - Efsane Sürüm</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a202c; --snake-color: #48bb78; --food-color: #f56565;
            --obstacle-color: #718096; --text-color: #f7fafc; --accent-color: #f6e05e;
            --snake-head-color: #a0fec0;
        }
        body { font-family: 'Roboto', sans-serif; touch-action: none; background-color: var(--bg-color); color: var(--text-color); }
        .game-font { font-family: 'Press Start 2P', cursive; }
        canvas {
            background-color: var(--bg-color);
            border: 4px solid var(--obstacle-color);
            border-radius: 0.5rem;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            transition: background-color 0.5s;
        }
        .control-btn {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .control-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
        }
        .overlay {
            position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center;
            background-color: rgba(0, 0, 0, 0.85); border-radius: 0.5rem; text-align: center;
        }
        .powerup-icon { font-size: 1.5rem; opacity: 0.7; }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-2 sm:p-4">

    <div class="w-full max-w-lg mx-auto text-center">
        <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold mb-2 game-font text-green-400">YILAN</h1>
        
        <div class="flex justify-between items-center mb-4 bg-gray-800 bg-opacity-50 p-3 rounded-lg shadow-inner">
            <div class="text-left">
                <p class="text-base sm:text-lg game-font">SKOR</p>
                <p id="score" class="text-2xl sm:text-3xl font-bold">0</p>
            </div>
            <!-- Dynamic area for timer or pause button -->
            <div id="center-display" class="text-center"></div>
            <div class="text-right">
                <p class="text-base sm:text-lg game-font">REKOR</p>
                <p id="highScore" class="text-3xl font-bold">0</p>
            </div>
        </div>
        
        <!-- Active power-ups display -->
        <div id="effects-display" class="h-8 flex justify-center items-center space-x-4 mb-2"></div>

        <div id="game-container" class="relative w-full aspect-square mb-4">
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <div id="menu-container">
                <!-- Main Menu -->
                <div id="menu-overlay" class="overlay">
                    <p class="text-xl sm:text-2xl game-font text-yellow-400 mb-6">OYUN MODU</p>
                    <button data-mode="classic" class="menu-btn control-btn bg-green-500 hover:bg-green-600 w-3/4 p-3 rounded-lg mb-4 game-font">KLASİK</button>
                    <button data-mode="timeAttack" class="menu-btn control-btn bg-blue-500 hover:bg-blue-600 w-3/4 p-3 rounded-lg mb-4 game-font">ZAMANA KARŞI</button>
                    <button data-mode="maze" class="menu-btn control-btn bg-purple-500 hover:bg-purple-600 w-3/4 p-3 rounded-lg mb-4 game-font">LABİRENT</button>
                    <button id="theme-menu-btn" class="control-btn bg-gray-500 hover:bg-gray-600 w-3/4 p-2 rounded-lg game-font text-sm mt-4">TEMALAR</button>
                </div>
                <!-- Difficulty Menu -->
                <div id="difficulty-overlay" class="overlay hidden">
                     <p class="text-xl sm:text-2xl game-font text-yellow-400 mb-6">ZORLUK SEVİYESİ</p>
                    <button data-difficulty="easy" class="difficulty-btn control-btn bg-green-500 hover:bg-green-600 w-3/4 p-3 rounded-lg mb-4 game-font">KOLAY</button>
                    <button data-difficulty="medium" class="difficulty-btn control-btn bg-orange-500 hover:bg-orange-600 w-3/4 p-3 rounded-lg mb-4 game-font">ORTA</button>
                    <button data-difficulty="hard" class="difficulty-btn control-btn bg-red-500 hover:bg-red-600 w-3/4 p-3 rounded-lg game-font">ZOR</button>
                    <button class="back-btn control-btn bg-gray-500 w-3/4 p-2 mt-4 text-sm game-font">GERİ</button>
                </div>
                <!-- Theme Menu -->
                <div id="theme-overlay" class="overlay hidden">
                     <p class="text-xl sm:text-2xl game-font text-yellow-400 mb-6">TEMA SEÇ</p>
                    <button data-theme="default" class="theme-btn control-btn bg-gray-700 w-3/4 p-3 rounded-lg mb-4 game-font">VARSAYILAN</button>
                    <button data-theme="forest" class="theme-btn control-btn bg-green-800 w-3/4 p-3 rounded-lg mb-4 game-font">ORMAN</button>
                    <button data-theme="ocean" class="theme-btn control-btn bg-blue-800 w-3/4 p-3 rounded-lg mb-4 game-font">OKYANUS</button>
                    <button data-theme="neon" class="theme-btn control-btn bg-indigo-800 w-3/4 p-3 rounded-lg game-font">NEON</button>
                    <button class="back-btn control-btn bg-gray-500 w-3/4 p-2 mt-4 text-sm game-font">GERİ</button>
                </div>
            </div>

            <!-- Message Overlay (Game Over / Paused) -->
            <div id="message-overlay" class="overlay" style="display: none;">
                <p id="message-text" class="text-3xl game-font text-yellow-400"></p>
                <p id="message-subtitle" class="mt-4 text-gray-300"></p>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobile-controls" class="grid grid-cols-3 gap-2 w-full max-w-xs mx-auto md:hidden hidden">
            <div></div>
            <button id="btn-up" class="control-btn bg-green-500 hover:bg-green-600 rounded-lg p-4"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg></button>
            <div></div>
            <button id="btn-left" class="control-btn bg-green-500 hover:bg-green-600 rounded-lg p-4"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
            <button id="btn-main-menu-mobile" class="control-btn bg-yellow-500 hover:bg-yellow-600 rounded-lg p-4 flex items-center justify-center game-font text-xs">MENÜ</button>
            <button id="btn-right" class="control-btn bg-green-500 hover:bg-green-600 rounded-lg p-4"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
            <div></div>
            <button id="btn-down" class="control-btn bg-green-500 hover:bg-green-600 rounded-lg p-4"><svg class="h-6 w-6 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg></button>
            <div></div>
        </div>

        <button id="btn-main-menu-desktop" class="hidden md:block control-btn bg-yellow-500 hover:bg-yellow-600 rounded-lg p-4 mt-4 w-full max-w-xs mx-auto game-font text-xl hidden">
            ANA MENÜ
        </button>
    </div>

<script>
    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas'), ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('highScore');
    const centerDisplay = document.getElementById('center-display'), effectsDisplay = document.getElementById('effects-display');
    const menuContainer = document.getElementById('menu-container'), messageOverlay = document.getElementById('message-overlay');
    const messageText = document.getElementById('message-text'), messageSubtitle = document.getElementById('message-subtitle');
    const mobileControls = document.getElementById('mobile-controls'), desktopMainMenuBtn = document.getElementById('btn-main-menu-desktop');
    
    // --- Game State ---
    const gridSize = 20;
    let canvasSize, tileCount;
    let snake, food, powerups, score, highScore, direction, changingDirection;
    let isGameOver, isPaused, gameLoop, gameSpeed, initialSpeed, difficulty, gameMode, timer;
    let obstacles = [], activeEffects = {};

    const themes = {
        default: { '--bg-color': '#1a202c', '--snake-color': '#48bb78', '--food-color': '#f56565', '--obstacle-color': '#718096', '--text-color': '#f7fafc', '--accent-color': '#f6e05e', '--snake-head-color': '#a0fec0' },
        forest: { '--bg-color': '#2f3e2f', '--snake-color': '#84a98c', '--food-color': '#e56b6f', '--obstacle-color': '#524636', '--text-color': '#cad2c5', '--accent-color': '#f6e05e', '--snake-head-color': '#a7d5b9' },
        ocean: { '--bg-color': '#003049', '--snake-color': '#669bbc', '--food-color': '#f77f00', '--obstacle-color': '#d62828', '--text-color': '#eae2b7', '--accent-color': '#fcbf49', '--snake-head-color': '#8eb9d4' },
        neon: { '--bg-color': '#0d0221', '--snake-color': '#00f5d4', '--food-color': '#ff0054', '--obstacle-color': '#9b5de5', '--text-color': '#f7f7ff', '--accent-color': '#fee440', '--snake-head-color': '#80ffee' },
    };
    
    // --- Sound Synthesis ---
    const synth = new Tone.Synth().toDestination();
    const sounds = {
        eat: () => synth.triggerAttackRelease("C5", "8n"),
        powerup: () => synth.triggerAttackRelease("G5", "8n"),
        gameOver: () => synth.triggerAttackRelease("C3", "4n"),
        pause: () => synth.triggerAttackRelease("E4", "8n"),
    };

    // --- Game Initialization ---
    function initializeGame() {
        if (gameLoop) clearTimeout(gameLoop);
        Object.values(activeEffects).forEach(effect => clearTimeout(effect.timeout));

        setupCanvas();
        
        snake = [{ x: 10, y: 10 }]; score = 0; powerups = []; obstacles = [];
        highScore = localStorage.getItem('snakeHighScore') || 0;
        direction = { x: 0, y: 0 };
        isGameOver = false; isPaused = false; changingDirection = false; activeEffects = {};
        
        scoreEl.textContent = score; highScoreEl.textContent = highScore;
        
        messageOverlay.style.display = 'none';
        menuContainer.style.display = 'block';
        showMenuScreen('menu-overlay');
        
        mobileControls.classList.add('hidden');
        desktopMainMenuBtn.classList.add('hidden');
        centerDisplay.innerHTML = '';
        effectsDisplay.innerHTML = '';
    }

    function startGame(_gameMode, _difficulty = null) {
        gameMode = _gameMode;
        difficulty = _difficulty;

        switch(gameMode) {
            case 'classic':
                if (!difficulty) return;
                const speeds = { easy: 150, medium: 120, hard: 90 };
                initialSpeed = speeds[difficulty];
                break;
            case 'timeAttack':
                initialSpeed = 80; timer = 90; break;
            case 'maze':
                initialSpeed = 130; break;
        }
        gameSpeed = initialSpeed;
        
        menuContainer.style.display = 'none';
        mobileControls.classList.remove('hidden');
        desktopMainMenuBtn.classList.remove('hidden');
        
        createObstacles();
        generateFood();
        
        // Setup central display (Timer or Pause Button)
        if (gameMode === 'timeAttack') {
            centerDisplay.innerHTML = `<div class="game-font text-lg">SÜRE: <span id="timer-display">${timer}</span></div>`;
        } else {
            centerDisplay.innerHTML = `<button id="pause-btn" class="control-btn bg-blue-500 hover:bg-blue-600 rounded-lg p-2 text-sm game-font">DURAKLAT</button>`;
            document.getElementById('pause-btn').addEventListener('click', togglePause);
        }

        changeDirection('RIGHT');
    }

    // --- Game Loop ---
    function main() {
        if (isPaused || isGameOver) {
            if (isGameOver) handleGameOver();
            return;
        }

        changingDirection = false;
        
        gameLoop = setTimeout(() => {
            if (gameMode === 'timeAttack') handleTimer();
            clearCanvas();
            drawObstacles();
            drawFood();
            drawPowerups();
            moveSnake();
            drawSnake();
            main();
        }, gameSpeed);
    }
    
    // --- Drawing ---
    function clearCanvas() { ctx.fillStyle = getCssVar('--bg-color'); ctx.fillRect(0, 0, canvas.width, canvas.height); }
    function drawSnake() {
        const isGhost = activeEffects.ghost;
        snake.forEach((part, index) => {
            ctx.globalAlpha = isGhost ? 0.6 : 1.0;
            ctx.fillStyle = index === 0 ? getCssVar('--snake-head-color') : getCssVar('--snake-color');
            ctx.strokeStyle = getCssVar('--bg-color');
            ctx.fillRect(part.x * tileCount, part.y * tileCount, tileCount, tileCount);
            ctx.strokeRect(part.x * tileCount, part.y * tileCount, tileCount, tileCount);
            ctx.globalAlpha = 1.0;
        });
    }
    function drawFood() {
        ctx.fillStyle = getCssVar('--food-color');
        ctx.beginPath();
        ctx.arc(food.x * tileCount + tileCount / 2, food.y * tileCount + tileCount / 2, tileCount / 2.5, 0, 2 * Math.PI);
        ctx.fill();
    }
    function drawPowerups() {
        ctx.font = `${tileCount * 0.8}px sans-serif`;
        powerups.forEach(p => {
             ctx.fillText(p.icon, p.x * tileCount, (p.y + 0.8) * tileCount);
        });
    }
    function drawObstacles() {
        ctx.fillStyle = getCssVar('--obstacle-color');
        obstacles.forEach(ob => ctx.fillRect(ob.x * tileCount, ob.y * tileCount, tileCount, tileCount));
    }
    
    // --- Logic ---
    function moveSnake() {
        if (direction.x === 0 && direction.y === 0) return;
        let head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

        const isGhost = activeEffects.ghost;
        // Wall collision / wrapping
        if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
            if(isGhost) {
                if (head.x < 0) head.x = gridSize - 1; else if (head.x >= gridSize) head.x = 0;
                if (head.y < 0) head.y = gridSize - 1; else if (head.y >= gridSize) head.y = 0;
            } else { isGameOver = true; return; }
        }
        
        snake.unshift(head);

        // Self and obstacle collision
        const hitSelf = snake.slice(1).some(part => part.x === head.x && part.y === head.y);
        const hitObstacle = obstacles.some(ob => ob.x === head.x && ob.y === head.y);
        if ((hitSelf || hitObstacle) && !isGhost) { isGameOver = true; return; }

        // Food collision
        let ateNormalFood = false;
        if (head.x === food.x && head.y === food.y) {
            ateNormalFood = true;
            score += 10;
            sounds.eat();
            generateFood();
            if (gameMode === 'classic' && gameSpeed > 40) gameSpeed -= 1;
            if (Math.random() > 0.65) spawnPowerup(); // 35% chance to spawn powerup
        }
        
        // Power-up collision
        const powerupIndex = powerups.findIndex(p => p.x === head.x && p.y === head.y);
        if (powerupIndex !== -1) {
            const powerup = powerups.splice(powerupIndex, 1)[0];
            activatePowerup(powerup.type);
        }
        
        if (!ateNormalFood) snake.pop();
        scoreEl.textContent = score;
    }

    function changeDirection(newDirection) {
        const isStarting = direction.x === 0 && direction.y === 0;
        if (changingDirection && !isStarting) return;
        const goingUp = direction.y === -1, goingDown = direction.y === 1, goingRight = direction.x === 1, goingLeft = direction.x === -1;

        let validMove = false;
        if (newDirection === 'UP' && !goingDown) { direction = { x: 0, y: -1 }; validMove = true; }
        if (newDirection === 'DOWN' && !goingUp) { direction = { x: 0, y: 1 }; validMove = true; }
        if (newDirection === 'LEFT' && !goingRight) { direction = { x: -1, y: 0 }; validMove = true; }
        if (newDirection === 'RIGHT' && !goingLeft) { direction = { x: 1, y: 0 }; validMove = true; }
        
        if (validMove) changingDirection = true;
        if (isStarting && validMove) main();
    }
    
    // --- Power-ups & Effects ---
    const powerupTypes = [
        { type: 'turtle', icon: '🐢' },
        { type: 'scissors', icon: '✂️' },
        { type: 'ghost', icon: '👻' },
    ];
    function spawnPowerup() {
        if (powerups.length > 2) return;
        const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
        const { x, y } = generateCoordinates();
        powerups.push({ x, y, ...randomType });
    }
    function activatePowerup(type) {
        sounds.powerup();
        if (activeEffects[type]) clearTimeout(activeEffects[type].timeout); // Reset timer if already active
        
        let duration = 7000; // 7 seconds
        switch(type) {
            case 'turtle':
                if(!activeEffects.turtle) { // only store original speed if not already slowed
                    activeEffects.turtle = { originalSpeed: gameSpeed };
                }
                gameSpeed = initialSpeed + 50;
                break;
            case 'scissors':
                const cutAmount = Math.min(snake.length - 2, 5);
                if(cutAmount > 0) snake.splice(snake.length - cutAmount);
                score += cutAmount * 5; // Bonus points for shortening
                return; // No duration needed
            case 'ghost':
                duration = 5000; // 5 seconds for ghost
                break;
        }

        const timeout = setTimeout(() => deactivatePowerup(type), duration);
        activeEffects[type] = { ...activeEffects[type], timeout, duration, startTime: Date.now() };
        updateEffectsDisplay();
    }

    function deactivatePowerup(type) {
        if(type === 'turtle' && activeEffects.turtle) gameSpeed = activeEffects.turtle.originalSpeed;
        delete activeEffects[type];
        updateEffectsDisplay();
    }

    function updateEffectsDisplay() {
        effectsDisplay.innerHTML = '';
        for(const type in activeEffects) {
            const effect = activeEffects[type];
            if (effect.duration) { // Only show timed effects
                const icon = powerupTypes.find(p => p.type === type).icon;
                effectsDisplay.innerHTML += `<div class="powerup-icon" id="effect-${type}">${icon}</div>`;
            }
        }
    }

    // --- Utility Functions ---
    function setupCanvas() {
        const container = document.getElementById('game-container');
        canvasSize = container.offsetWidth;
        canvas.width = canvasSize; canvas.height = canvasSize;
        tileCount = canvas.width / gridSize;
    }
    function isLocationOccupied(x, y) {
        return snake.some(p => p.x === x && p.y === y) || obstacles.some(o => o.x === x && o.y === y);
    }
    function generateCoordinates() {
        let x, y;
        do { x = Math.floor(Math.random() * gridSize); y = Math.floor(Math.random() * gridSize);
        } while (isLocationOccupied(x, y));
        return { x, y };
    }
    function generateFood() { food = generateCoordinates(); }
    function createObstacles() {
        obstacles = [];
        if (gameMode === 'classic') {
            if (difficulty === 'easy') return;
            const count = difficulty === 'medium' ? 5 : 10;
            for(let i=0; i<count; i++) obstacles.push(generateCoordinates());
        } else if (gameMode === 'maze') {
            // Simple maze generation
            for (let i = 2; i < gridSize - 2; i++) {
                if (Math.random() > 0.5) obstacles.push({x: i, y: 4}, {x: gridSize-1-i, y: gridSize-5});
                else obstacles.push({x: 4, y: i}, {x: gridSize-5, y: gridSize-1-i});
            }
        }
    }
    function togglePause() {
        if (isGameOver || gameMode === 'timeAttack') return;
        isPaused = !isPaused;
        sounds.pause();
        const pauseBtn = document.getElementById('pause-btn');
        if (isPaused) {
            clearTimeout(gameLoop);
            messageText.textContent = 'DURAKLATILDI';
            messageSubtitle.textContent = 'Devam etmek için butona veya P tuşuna basın.';
            messageOverlay.style.display = 'flex';
            pauseBtn.textContent = 'DEVAM ET';
        } else {
            messageOverlay.style.display = 'none';
            pauseBtn.textContent = 'DURAKLAT';
            main();
        }
    }
    function handleGameOver() {
        sounds.gameOver();
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('snakeHighScore', highScore);
            highScoreEl.textContent = highScore;
        }
        messageText.innerHTML = `OYUN BİTTİ!<br><span class="text-xl">SKOR: ${score}</span>`;
        messageSubtitle.textContent = 'Yeniden oynamak için Ana Menü\'ye dönün.';
        messageOverlay.style.display = 'flex';
        centerDisplay.innerHTML = '';
        desktopMainMenuBtn.textContent = 'ANA MENÜ';
    }
    function handleTimer() {
        timer -= gameSpeed / 1000;
        document.getElementById('timer-display').textContent = Math.ceil(timer);
        if (timer <= 0) {
            isGameOver = true;
            document.getElementById('timer-display').textContent = 0;
        }
    }
    
    // --- UI & Menu Handling ---
    function showMenuScreen(screenId) {
        document.querySelectorAll('#menu-container .overlay').forEach(el => el.classList.add('hidden'));
        document.getElementById(screenId).classList.remove('hidden');
    }
    function applyTheme(themeName) {
        const theme = themes[themeName];
        for (const [key, value] of Object.entries(theme)) {
            document.documentElement.style.setProperty(key, value);
        }
        localStorage.setItem('snakeTheme', themeName);
    }
    function getCssVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name); }

    // --- Event Listeners ---
    document.querySelectorAll('.menu-btn').forEach(btn => btn.addEventListener('click', e => {
        Tone.start(); // Ensure audio context is started
        const mode = e.currentTarget.dataset.mode;
        if (mode === 'classic') {
            showMenuScreen('difficulty-overlay');
        } else {
            startGame(mode);
        }
    }));
    document.querySelectorAll('.difficulty-btn').forEach(btn => btn.addEventListener('click', e => {
        startGame('classic', e.currentTarget.dataset.difficulty);
    }));
    document.getElementById('theme-menu-btn').addEventListener('click', () => showMenuScreen('theme-overlay'));
    document.querySelectorAll('.theme-btn').forEach(btn => btn.addEventListener('click', e => applyTheme(e.currentTarget.dataset.theme)));
    document.querySelectorAll('.back-btn').forEach(btn => btn.addEventListener('click', () => showMenuScreen('menu-overlay')));

    document.querySelectorAll('#btn-main-menu-mobile, #btn-main-menu-desktop').forEach(b => b.addEventListener('click', initializeGame));

    document.addEventListener('keydown', (e) => {
        if(isGameOver) return;
        if (e.key === 'p') { e.preventDefault(); togglePause(); return; }
        changeDirection({ ArrowUp: 'UP', ArrowDown: 'DOWN', ArrowLeft: 'LEFT', ArrowRight: 'RIGHT', w: 'UP', s: 'DOWN', a: 'LEFT', d: 'RIGHT' }[e.key]);
    });
    
    // Mobile Buttons
    document.getElementById('btn-up').addEventListener('click', () => changeDirection('UP'));
    document.getElementById('btn-down').addEventListener('click', () => changeDirection('DOWN'));
    document.getElementById('btn-left').addEventListener('click', () => changeDirection('LEFT'));
    document.getElementById('btn-right').addEventListener('click', () => changeDirection('RIGHT'));

    // Swipe Controls
    let touchStartX = 0, touchStartY = 0;
    canvas.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY;
    });
    canvas.addEventListener('touchend', e => {
        if (isGameOver || isPaused) return;
        let touchEndX = e.changedTouches[0].clientX, touchEndY = e.changedTouches[0].clientY;
        let dx = touchEndX - touchStartX, dy = touchEndY - touchStartY;
        if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return; // Ignore taps
        if (Math.abs(dx) > Math.abs(dy)) changeDirection(dx > 0 ? 'RIGHT' : 'LEFT');
        else changeDirection(dy > 0 ? 'DOWN' : 'UP');
    });

    window.addEventListener('resize', initializeGame);

    // --- Initial Call ---
    applyTheme(localStorage.getItem('snakeTheme') || 'default');
    initializeGame();
</script>
</body>
</html>
